#! /usr/bin/env python

import os
import signal
import subprocess
import sys
import threading

import actionlib
import clingo_interface_gui.msg
import rospy

# Brings in the SimpleActionClient


domainFile = sys.argv[1]
queryFile = sys.argv[3]
initialFile = sys.argv[2]

class Atom(object):

    TERM = "term"
    ACTION = "action"
    FLUENT = "fluent"
    VARIABLE = "variable"
    LIST = "list"

    ACTION_NAMES = ["sense", "goto", "gothrough", "callforopen", "approach"]
    FLUENT_NAMES = ["at", "open", "visited", "beside", "open", "visited", 
                    "beside", "inside", "goal", "facing"]

    def __init__(self, name, value=None, time=None, negated=False):

        if value != None:
            if name.find("(") != -1:
                raise ValueError("Malformed atom - name: %s, value: %s"%
                                 str(name),str(value))
            if isinstance(value, Atom):
                self.value = value
            else:
                self.value = Atom(value)

        else:
            # Need to parse atom from string 
            start = [-1]
            end = []
            parenthesis_count = 0
            self.type = None
            for i in range(len(name)):
                if name[i] == "," and parenthesis_count == 0:
                    self.type == Atom.LIST
                    start.append(i)
                    end.append(i)
                if name[i] == "(":
                    parenthesis_count+=1
                if name[i] == ")":
                    parenthesis_count-=1
                if parenthesis_count < 0:
                    raise ValueError(
                        "Malformed atom - Need '(' before ')' - %s"%
                        str(name))
            end.append(len(name))
            if parenthesis_count != 0:
                raise ValueError("Malformed atom - Expected ')' at end - %s"%
                                 str(name))

            if self.type == Atom.LIST:
                self.name = None
                self.value = [Atom(name[start[i]+1:end[i]]) 
                              for i in range(len(start))]
                return
                
            if name.find("(") == -1:
                self.name = None
                self.type = Atom.VARIABLE
                self.value = name

            if self.type != None:
                if time != None:
                    raise ValueError(
                        "Malformed atom - List/Var cannot be stamped - %s"%
                        str(name))
                if negated:
                    raise ValueError(
                        "Malformed atom - List/Var cannot be negated - %s"%
                        str(name))
                self.time = None
                self.negated = False
                return

            self.name = name[:name.find("(")]
            self.value = Atom(name[name.find("(")+1:name.rfind(")")])

        # If we are here, then the Atom is a Term, Fluent or Action
        self.negated = False
        if self.name[0] == '-':
            self.negated = True
            self.name = self.name[1:]
        if negated:
            self.negated = not self.negated

        # Find if stamped
        if time == None:
            if self.value.type == Atom.LIST:
                try:
                    self.time = int(str(self.value.value[-1]))
                    self.value.value = self.value.values[:-1]
                    if len(self.value.value) == 1:
                        self.value = self.value.value[0]
                except ValueError:
                    # This is a term
                    self.time = None
                    self.type = Atom.TERM
                    return
        else:
            self.time = time

        if self.name in Atom.ACTION_NAMES:
            self.type = Atom.ACTION
            return
        if self.name in Atom.FLUENT_NAMES:
            self.type = Atom.FLUENT
            return

        raise ValueError("Malformed atom - Unknown action/fluent: %s"%str(name))

    def __str__(self):
        if self.type == Atom.VARIABLE:
            return self.value
        if self.type == Atom.LIST:
            return ",".join(self.value)
        if self.type == Atom.TERM:
            return self.name + "(" + str(self.value) + ")"
        return self.name + "(" + str(self.value) + "," + str(self.time) + ")"

    def __eq__(self, other):
        return self.name == other.name and\
                self.type == other.type and\
                self.value == other.value

    def __ne__(self, other):
        return not self.__eq__(other)

def parse_atoms(atom_string):
    return [Atom(word) for word in atom_string.split()]

def parse_plan(plan_string):
    atoms = parse_atoms(plan_string)
    plan = [atom for atom in atoms if atom.type == Atom.ACTION]
    states = [atom for atom in atoms if atom.type == Atom.FLUENT]
    plan = sorted(plan, key=lambda atom: atom.time)
    states = sorted(states, key=lambda atom: atom.time)
    return plan,states

class Command(object):

    def __init__(self, cmd, outfile):
        self.cmd = cmd
        self.process = None
        self.outfile = outfile

    def run(self, timeout):
        def target():
            self.process = subprocess.Popen(self.cmd, shell=True, 
                                            stdout=self.outfile, 
                                            preexec_fn=os.setsid)
            self.process.communicate()

        thread = threading.Thread(target=target)
        thread.start()

        thread.join(timeout)
        if thread.is_alive():
            os.killpg(self.process.pid, signal.SIGTERM)
            thread.join()
        #print "Process RetCode: " + str(self.process.returncode)
        self.outfile.close()
        return self.process.returncode

class ClingoWrapper(object):

    def __init__(self):
        self.clingo_timeout = rospy.get_param("clingo_timeout", 60)
        self.clingo_steps = rospy.get_param("clingo_steps", 20)
        self.clingo_threads = rospy.get_param("clingo_threads", 6)
        self.domain_file = rospy.get_param("domain_file", "nav")

    def get_plan(self, additional_files, actions):

        # Run clingo
        additional_files_str = " ".join(additional_files)
        out_file = open("result", "w")
        clingo_command = Command("gringo -c maxstep=" + self.clingo_steps +
                                 " " + self.domain_file + 
                                 " " + additional_files_str + 
                                 " | rosrun clasp clasp -t " + 
                                 self.clingo_threads, out_file)
        clingo_command.run(self.clingo_timeout)

        # Parse Output
        out_file = open("result","r")
        if out_file.readline() == "UNSATISFIABLE\n":
            out_file.close()
            return False, 0, None, None

        linelist = []
        for line in out_file:
            linelist.append(line)
            if line[:13] == "Optimization:" and linelist[-2][:9] != "  Optimum":
                optimization = 1
                optimization_line = linelist[-1]
                print optimization_line
                plan_line = linelist[-2]
        try:
            plan, states = parse_plan(plan_line)
        except ValueError as e:
            rospy.logerr("Received plan from clasp, but unable to parse plan:" +
                         plan_line)
            rospy.logerr("  Error: " + str(e))
            return False, 0, None, None

        out_file.close()
        return True, optimization, plan, states

def PlannerClient():
    client = actionlib.SimpleActionClient('clingo_interface_gui', clingo_interface_gui.msg.ClingoInterfaceAction)
    client.wait_for_server()

#initial state sensing:

    command = clingo_interface_gui.msg.ClingoFluent("noop", [])
    sensedfluent =  clingo_interface_gui.msg.ClingoFluent()
    evalfluent = []
    
    goal = clingo_interface_gui.msg.ClingoInterfaceGoal(command, sensedfluent, evalfluent)
    client.send_goal(goal)
    client.wait_for_result()
    result = client.get_result()
    
    inputFile = open(sys.argv[2],"w")
    for fluent in result.observable_fluents:
        op = fluent.op
        arg = fluent.args
        curstate = (str(0),[op]+arg)
        s="("
        for i in range(1,len(curstate[1])):
            s = s + curstate[1][i]+","
            s = s+"0).\n"
            newinit = curstate[1][0]+s
        inputFile.write(newinit)
        print "Initial sensing:"+ newinit
    inputFile.close()

    result = GeneratePlan()
    SendoutPlan(result,client)

#task finished, send out "finish" action
    finish = clingo_interface_gui.msg.ClingoFluent("finish",[])
    fsensedfluent =  clingo_interface_gui.msg.ClingoFluent()
    fevalfluent = []
    
    goalfinished = clingo_interface_gui.msg.ClingoInterfaceGoal(finish,fsensedfluent, fevalfluent)
    client.send_goal(goalfinished)
    print "Finish goal"
    client.wait_for_result()

def SendoutPlan(result,client):
    plan = result[0]
    state = result[1]

    command = clingo_interface_gui.msg.ClingoFluent()
    sense_fluent = clingo_interface_gui.msg.ClingoFluent()
#    evaluate_fluent = clingo_interface_gui.msg.ClingoFluent()
    evaluate_fluent =[]
    for i in range(len(plan)):
        s = plan[i]
        if s[1][0] == "sense":
            command.op = "sense"
            w = s[1][1] # the fluent to be sensed
            sense_fluent.op = w[:w.find("(")]
            if w.find("(")!=-1:
                a2 = w[w.find("(")+1:w.rfind(")")] # list of arguments of sense
                sense_fluent.args = a2.split(",")
        else:
            command = clingo_interface_gui.msg.ClingoFluent(s[1][0], [s[1][1]])
        

        print "action:", s[1][0], s[1][1]
        goal = clingo_interface_gui.msg.ClingoInterfaceGoal(command, sense_fluent, evaluate_fluent)
#        print goal
        client.send_goal(goal)
        client.wait_for_result()
        result= client.get_result()
#        print result
        expectstate = []
        for ss in state:
            if (i+1 < len(plan)):
                nexttime = plan[i+1][0]
            else:    
                nexttime = s[0]+1        
            if ss[0]==nexttime:
                expectstate.append(ss)
    #        print expectstate

        needreplan = 0
        for fluent in result.observable_fluents:
            op = fluent.op
            arg = fluent.args
            if (i+1 < len(plan)):
                nexttime = plan[i+1][0]
            else:    
                nexttime = s[0]+1        

            curstate = (nexttime,[op]+arg)
                
            if curstate in expectstate:    
                print "observation as expected: ", curstate
            else:
                print "unexpected observation: ", curstate
                needreplan = 1
                break
    
        if needreplan == 0:
            for se in expectstate:
                if se[1][0]=="goal":
                    goalinfo = "goal("+ se[1][1] + ","+str(se[0])+")."
                    print "archieve "+goalinfo        
                    inputFile3 = open(sys.argv[3],"a")
                    inputFile3.write(goalinfo)
                    inputFile3.close()
        if needreplan == 1:
            #generate a new initial state and calling for replan
            inputFile = open(sys.argv[2],"w")
            inputFile2 = open(sys.argv[3],"a")
            for fluent in result.observable_fluents:
                op = fluent.op
                arg = fluent.args                
                curstate = (plan[i+1][0]-1,[op]+arg)
            #    print curstate
                s="("
                for p in range(1,len(curstate[1])): #arguments from second elem in list
                    s = s + curstate[1][p]+","
                s = s+"0)."
                newinit = curstate[1][0]+s

                
                print "New initial:" + newinit
                if op in newknowledge:
                    inputFile2.write(newinit)
                else:
                    inputFile.write(newinit)
            inputFile2.close()
            inputFile.close()
            newresult = GeneratePlan()
            
            SendoutPlan(newresult,client)
            break


if __name__ == '__main__':
#    print GeneratePlan()
    try:
        # Initializes a rospy node so that the SimpleActionClient can
        # publish and subscribe over ROS.
        rospy.init_node('asp_planner_client_py')

  
        PlannerClient()
  #      print "Result:", result
    except rospy.ROSInterruptException:
        print "program interrupted before completion"



#! /usr/bin/env python

import os
import signal
import subprocess
import threading

import rospy

from bwi_planning.srv import CostLearnerInterface
from bwi_planning_common.srv import PlannerInterface
from bwi_planning_common.msg import PlannerAtom
from bwi_tools import WallRate
from segbot_gui.srv import QuestionDialog, QuestionDialogRequest
from segbot_simulation_apps.srv import DoorHandlerInterface
from std_srvs.srv import Empty

class Atom(object):

    TERM = "term"
    ACTION = "action"
    FLUENT = "fluent"
    VARIABLE = "variable"
    LIST = "list"

    ACTION_NAMES = ["askploc", "greet", "gothrough", "opendoor", "approach"]
    FLUENT_NAMES = ["at", "open", "visiting", "beside", "open", 
                    "beside", "inside", "goal", "facing"]

    def __init__(self, name, value=None, time=None, negated=False):

        #print "parsing: " + str(name)

        if value != None:
            if name.find("(") != -1:
                raise ValueError("Malformed atom - name: %s, value: %s"%
                                 str(name),str(value))
            self.name = name
            if isinstance(value, Atom):
                self.value = value
            else:
                self.value = Atom(value)

        else:
            # Need to parse atom from string 
            start = [-1]
            end = []
            parenthesis_count = 0
            self.type = None
            for i in range(len(name)):
                if name[i] == "," and parenthesis_count == 0:
                    self.type = Atom.LIST
                    start.append(i)
                    end.append(i)
                if name[i] == "(":
                    parenthesis_count+=1
                if name[i] == ")":
                    parenthesis_count-=1
                if parenthesis_count < 0:
                    raise ValueError(
                        "Malformed atom - Need '(' before ')' - %s"%
                        str(name))
            end.append(len(name))
            if parenthesis_count != 0:
                raise ValueError("Malformed atom - Expected ')' at end - %s"%
                                 str(name))

            if self.type == Atom.LIST:
                self.name = None
                self.value = [Atom(name[start[i]+1:end[i]]) 
                              for i in range(len(start))]
            elif name.find("(") == -1:
                self.name = None
                self.type = Atom.VARIABLE
                self.value = name

            if self.type != None:
                if time != None:
                    raise ValueError(
                        "Malformed atom - List/Var cannot be stamped - %s"%
                        str(name))
                if negated:
                    raise ValueError(
                        "Malformed atom - List/Var cannot be negated - %s"%
                        str(name))
                self.time = None
                self.negated = False
                return

            self.name = name[:name.find("(")]
            self.value = Atom(name[name.find("(")+1:name.rfind(")")])

        # If we are here, then the Atom is a Term, Fluent or Action
        self.negated = False
        if self.name[0] == '-':
            self.negated = True
            self.name = self.name[1:]
        if negated:
            self.negated = not self.negated

        # Find if stamped
        if time == None:
            if self.value.type == Atom.LIST:
                try:
                    self.time = int(str(self.value.value[-1]))
                    self.value.value = self.value.value[:-1]
                    if len(self.value.value) == 1:
                        self.value = self.value.value[0]
                except ValueError:
                    # This is a term
                    self.time = None
                    self.type = Atom.TERM
                    return
            else:
                self.time = None
                self.type = Atom.TERM
                return
        else:
            self.time = time

        if self.name in Atom.ACTION_NAMES:
            self.type = Atom.ACTION
            return
        if self.name in Atom.FLUENT_NAMES:
            self.type = Atom.FLUENT
            return

        raise ValueError("Malformed atom - Unknown action/fluent: %s"%str(name))

    def conflicts_with(self, other):

        # Check for hard negation
        if self.name == other.name and \
           self.value == other.value and \
           self.negated != other.negated:
            return True

        # Check for uniqueness constraints
        if (self.name == "at" and other.name == "at" or \
            self.name == "facing" and other.name == "facing" or \
            self.name == "beside" and other.name == "beside") and \
           self.value != other.value and \
           not self.negated and not other.negated:
            return True

        # Check for uniqueness constraint for inside
        # if the person is same, but the location is different and both 
        # fluents are not negated
        if self.name == "inside" and other.name == "inside" and \
           self.value.value[0] == other.value.value[0] and \
           self.value.value[1] != other.value.value[1] and \
           not self.negated and not other.negated:
            return True

        return False

    def __str__(self):
        prefix = '-' if self.negated else ''
        if self.type == Atom.VARIABLE:
            return self.value
        if self.type == Atom.LIST:
            return ",".join([str(atom) for atom in self.value])
        if self.type == Atom.TERM:
            return prefix + self.name + "(" + str(self.value) + ")"
        return prefix + self.name + \
                "(" + str(self.value) + "," + str(self.time) + ")"

    def __repr__(self):
        return self.__str__()

    def __eq__(self, other):
        return self.name == other.name and \
                self.type == other.type and \
                self.value == other.value and \
                self.negated == other.negated

    def __ne__(self, other):
        return not self.__eq__(other)

def parse_atoms(atom_string):
    return [Atom(word) for word in atom_string.split()]

def parse_plan(plan_string):
    atoms = parse_atoms(plan_string)
    plan = [atom for atom in atoms if atom.type == Atom.ACTION]
    states = [atom for atom in atoms if atom.type == Atom.FLUENT]
    plan = sorted(plan, key=lambda atom: atom.time)
    states = sorted(states, key=lambda atom: atom.time)
    return plan,states

class ClingoCommand(object):

    def __init__(self, cmd, outfile):
        self.cmd = cmd
        self.process = None
        self.outfile = outfile

    def run(self, timeout):
        rospy.logdebug("Running command: " + self.cmd)
        def target():
            self.process = subprocess.Popen(self.cmd, shell=True, 
                                            stdout=self.outfile, 
                                            preexec_fn=os.setsid)
            self.process.communicate()

        thread = threading.Thread(target=target)
        thread.start()

        thread.join(timeout)
        if thread.is_alive():
            os.killpg(self.process.pid, signal.SIGTERM)
            thread.join()
        #print "Process RetCode: " + str(self.process.returncode)
        self.outfile.close()
        return self.process.returncode

class ClingoWrapper(object):

    def __init__(self):
        self.clingo_timeout = rospy.get_param("~clingo_timeout", 60)
        self.clingo_steps = rospy.get_param("~clingo_steps", 20)
        self.clingo_threads = rospy.get_param("~clingo_threads", 6)
        self.domain_file = rospy.get_param("~domain_file")

    def get_plan(self, additional_files):

        for n in range(self.clingo_steps):
            # Run clingo
            additional_files_str = " ".join(additional_files)
            out_file = open("result", "w")
            clingo_command = ClingoCommand("gringo -c n=" + str(n) +
                                     " " + self.domain_file + 
                                     " " + additional_files_str + 
                                     " | rosrun clasp clasp -t " + 
                                     str(self.clingo_threads), out_file)
            clingo_command.run(self.clingo_timeout)

            # Parse Output
            out_file = open("result","r")
            linelist = []
            no_plan_available = False
            for line in out_file:
                linelist.append(line)
                if line[:13] == "UNSATISFIABLE":
                    out_file.close()
                    no_plan_available = True
                    break
                if line[:11] == "SATISFIABLE":
                    optimization = n
                    plan_line = linelist[-2]

            if no_plan_available:
                continue

            try:
                plan, states = parse_plan(plan_line)
            except ValueError as e:
                rospy.logerr("Received plan from clasp, but unable to parse plan:" +
                             plan_line)
                rospy.logerr("  Error: " + str(e))
                return False, 0, None, None

            out_file.close()
            return True, optimization, plan, states
        return False, 0, None, None

    def get_plan_costs(self, additional_files):

        # Run clingo
        additional_files_str = " ".join(additional_files)
        out_file = open("result", "w")
        clingo_command = ClingoCommand("gringo -c n=" + str(self.clingo_steps) +
                                 " " + self.domain_file + 
                                 " " + additional_files_str + 
                                 " | rosrun clasp clasp -t " + 
                                 str(self.clingo_threads), out_file)
        ret_code = clingo_command.run(self.clingo_timeout)

        if ret_code != 0:
            rospy.logerr("Clasp encountered error")
            return False, 0, None, None

        # Parse Output
        out_file = open("result","r")
        if out_file.readline() == "UNSATISFIABLE\n":
            out_file.close()
            return False, 0, None, None

        linelist = []
        for line in out_file:
            linelist.append(line)
            if line[:13] == "Optimization:" and linelist[-2][:9] != "  Optimum":
                optimization = 1
                optimization_line = linelist[-1]
                plan_line = linelist[-2]

        try:
            plan, states = parse_plan(plan_line)
        except ValueError as e:
            rospy.logerr("Received plan from clasp, but unable to parse plan:" +
                         plan_line)
            rospy.logerr("  Error: " + str(e))
            return False, 0, None, None

        out_file.close()
        return True, optimization, plan, states

class ActionExecutor(object):

    def __init__(self, dry_run=False):

        self.dry_run = dry_run
        self.auto_open_door = rospy.get_param("auto_open_door", False)

        # segbot gui
        rospy.wait_for_service('question_dialog')
        self.gui = rospy.ServiceProxy('question_dialog', QuestionDialog)

        if not self.dry_run: 

            # logical task executor
            rospy.wait_for_service('execute_logical_goal')
            self.nav_executor = rospy.ServiceProxy('execute_logical_goal', 
                                             PlannerInterface)

            # simulation - automatic door opening
            if self.auto_open_door:
                self.update_doors = rospy.ServiceProxy('update_doors', 
                                                 DoorHandlerInterface)

    def sense_initial_state(self):

        if self.dry_run:
            # Assume initial file supplied by user has initial state
            return

        if self.auto_open_door:
            self.update_doors("", False, True) #Close all doors

        result = self.nav_executor(PlannerAtom("noop", []))
        
        initial_file = open(self.initial_file,"w")
        display_message = "Initial state: "
        for fluent in result.observations:
            atom = Atom(fluent.op, ",".join(fluent.args), time=0)
            initial_file.write(str(atom) + ".\n")
            display_message += str(atom) + " "
        initial_file.close()
        rospy.loginfo(display_message)

    def execute_action(self, action, next_state, next_step):

        rospy.loginfo("Executing action: " + str(action))

        if self.dry_run and action.name != "askploc":
            rospy.loginfo("  Observations: " + str(next_state))
            return next_state

        if (action.name == "approach" or action.name == "gothrough"):
            response = self.nav_executor(PlannerAtom(action.name, 
                                                     [str(action.value)]))
            result = response.observations

        # opendoor, askploc, greet
        if action.name == "opendoor":
            if self.auto_open_door:
                self.update_doors(str(action.value), True, False)
            else:
                self.gui(QuestionDialogRequest.DISPLAY,
                         "Can you open door " + str(action.value) + "?",
                         [], 0.0)
            rate = WallRate(0.5)
            for i in range(60):
                response = self.nav_executor(PlannerAtom("sensedoor", 
                                              [str(action.value)]))
                result = response.observations
                for fluent in result:
                    if (fluent.name == "open" and 
                        fluent.value[0] == str(action.value)):
                        self.gui(QuestionDialogRequest.DISPLAY,
                                 "Thanks!!", [], 0.0)
                        break

                rate.sleep()

        if action.name == "askploc":
            response = self.gui(QuestionDialogRequest.TEXT_QUESTION, 
                           "Can you tell me where " + str(action.value) + "is?",
                           [], 30.0)
            result = [PlannerAtom("inside",[str(action.value), response.text])] 

        if action.name == "greet":
            self.gui(QuestionDialogRequest.DISPLAY,
                     "Hello " + str(action.value) + "?",
                     [], 0.0)
            result =  [PlannerAtom("visiting",[str(action.value)])]

        observations = []
        for fluent in result:
            observations.append(Atom(fluent.op, ",".join(fluent.args),time=next_step))
        rospy.loginfo("  Observations: " + str(observations))
        return observations


class PlannerClient(object):

    def __init__(self):
        self.dry_run = rospy.get_param("~dry_run", False)
        self.clingo_interface = ClingoWrapper()
        self.initial_file = rospy.get_param("~initial_file")
        self.query_file = rospy.get_param("~query_file")
        self.domain_cost_file = rospy.get_param("~domain_cost_file", None)
        self.costs_file = rospy.get_param("~costs_file", None)
        self.enable_learning = rospy.get_param("~enable_learning", False)

        if self.enable_learning: 
            rospy.wait_for_service('cost_learner/finalize_episode')
            rospy.wait_for_service('cost_learner/add_sample')
            self.finalize_episode = \
                    rospy.ServiceProxy('cost_learner/finalize_episode', Empty)
            self.add_sample = \
                    rospy.ServiceProxy('cost_learner/add_sample', 
                                       CostLearnerInterface)

    def construct_initial_state(self, previous_state, observations):
        # Change time to 0 in previous state and
        # replace all conflicts with observations

        new_state = []

        for atom in previous_state:
            atom.time = 0
            add_atom = True
            for observation in observations:
                if observation.conflicts_with(atom):
                    add_atom = False
            if add_atom:
                new_state.append(atom)

        for observation in observations:
            observation.time = 0
            new_state.append(observation)

        initial_file = open(self.initial_file,"w")
        display_message = "Constructed state: "
        for atom in new_state:
            initial_file.write(str(atom) + ".\n")
            display_message += str(atom) + " "
        initial_file.close()
        rospy.loginfo(display_message)

    def send_finish(self):
        if self.enable_learning:
            self.finalize_episode()

    def start(self):
        self.executor.sense_initial_state()
        while True:
            if self.domain_cost_file != None:
                plan_available, optimization, plan, states = \
                        self.clingo_interface.get_plan_costs([self.initial_file,
                                                      self.query_file,
                                                      self.domain_cost_file,
                                                      self.costs_file])
            else:
                plan_available, optimization, plan, states = \
                        self.clingo_interface.get_plan([self.initial_file,
                                                      self.query_file])
            if not plan_available:
                rospy.logfatal("No plan found to complete task!")
                break
            rospy.loginfo("Found plan (optimization = %i): %s"%(optimization,
                                                                plan))

            step = 0
            need_replan = False
            for action in plan:
                current_state = [state for state in states
                                 if state.time == step]
                next_state = [state for state in states
                              if state.time == step+1]
                # TODO record time here and add sample
                observations = \
                        self.executor.execute_action(action, next_state, step+1) 
                for observation in observations:
                    if observation not in next_state:
                        rospy.logwarn("Unexpected observation: " + str(observation))
                        need_replan = True
                        break
                if need_replan:
                    break
                step += 1

            if need_replan:
                self.construct_initial_state(current_state, observations)
                continue
            
            rospy.loginfo("Plan successful!")
            self.send_finish()
            break


if __name__ == '__main__':
    try:
        rospy.init_node('planner_krr2014')
        client = PlannerClient()
        client.start()
    except rospy.ROSInterruptException:
        rospy.logwarn("Planner interrupted before completeion!")


